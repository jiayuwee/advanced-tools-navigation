# 性能服务

<cite>
**本文档引用的文件**   
- [performanceService.ts](file://src/services/performanceService.ts)
- [usePerformance.ts](file://src/composables/usePerformance.ts)
- [optimize-build.mjs](file://scripts/performance/optimize-build.mjs)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介
本文档深入介绍了`performanceService`在前端性能指标收集与上报方面的技术实现。重点说明了其监控的关键性能指标（如首屏加载时间、组件渲染耗时、API响应延迟）及其采集时机，详细描述了数据上报机制（如批量发送、节流控制）与后端存储方案。通过`usePerformance`组合式函数，展示了在关键路径中埋点的使用方法。文档还涵盖了性能数据模型、隐私合规处理、异常性能告警机制、与构建优化脚本(optimize-build.mjs)的联动策略，以及基于数据的性能优化建议闭环。

## 项目结构
项目结构清晰地划分了不同功能模块。性能监控的核心逻辑位于`src/services/performanceService.ts`，组合式函数封装在`src/composables/usePerformance.ts`，而构建优化脚本则位于`scripts/performance/optimize-build.mjs`。这种分层设计确保了关注点分离，便于维护和扩展。

**Section sources**
- [performanceService.ts](file://src/services/performanceService.ts)
- [usePerformance.ts](file://src/composables/usePerformance.ts)
- [optimize-build.mjs](file://scripts/performance/optimize-build.mjs)

## 核心组件
本系统的核心组件包括`performanceService`，负责性能数据的收集、队列管理和上报；`usePerformance`组合式函数，为Vue组件提供便捷的性能监控API；以及`optimize-build.mjs`构建脚本，用于在构建阶段进行性能优化分析。

**Section sources**
- [performanceService.ts](file://src/services/performanceService.ts#L1-L50)
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L50)
- [optimize-build.mjs](file://scripts/performance/optimize-build.mjs#L1-L50)

## 架构概述
系统采用客户端-服务端架构。前端通过`performanceService`实例化一个单例，利用浏览器的Performance API和自定义埋点来收集性能数据。数据被暂存在内存队列中，并通过批量和定时机制上报至Supabase后端。后端使用`get_performance_report`函数生成聚合报告，供前端查询。

```mermaid
graph TB
subgraph "前端"
A[Performance API] --> B[performanceService]
C[usePerformance] --> B
B --> D[Metrics Queue]
D --> E[Supabase]
end
subgraph "后端"
E --> F[(performance_metrics 表)]
G[get_performance_report 函数] --> F
G --> H[PerformanceReport]
end
H --> I[前端报告展示]
```

**Diagram sources **
- [performanceService.ts](file://src/services/performanceService.ts#L1-L50)
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L50)

## 详细组件分析

### performanceService 分析
`performanceService`是性能监控的核心服务，采用单例模式实现，确保全局唯一实例。

#### 类图
```mermaid
classDiagram
class PerformanceService {
-sessionId : string
-userId? : string
-isEnabled : boolean
-batchSize : number
-batchTimeout : number
-metricsQueue : PerformanceMetric[]
-batchTimer? : number
+setUserId(userId : string) : void
+setEnabled(enabled : boolean) : void
+trackMetric(type, name, value, unit, additionalData) : void
+trackCustomMetric(name, value, unit) : void
+trackAPICall(endpoint, method, duration, status, size) : void
+trackUserAction(action, element, duration?) : void
+trackError(errorInfo : ErrorInfo) : void
+getPerformanceReport(startDate, endDate) : Promise~PerformanceReport~
+destroy() : void
}
class PerformanceMetric {
+id : string
+metric_type : "page_load"|"api_call"|"user_action"|"error"|"navigation"
+metric_name : string
+value : number
+unit : "ms"|"bytes"|"count"|"percentage"
+page_url : string
+user_agent : string
+user_id? : string
+session_id : string
+additional_data? : Record~string, any~
+created_at : string
}
PerformanceService --> PerformanceMetric : "包含"
```

**Diagram sources **
- [performanceService.ts](file://src/services/performanceService.ts#L1-L500)

#### 关键指标采集流程
```mermaid
flowchart TD
Start([开始]) --> A[初始化 PerformanceObserver]
A --> B[观察 navigation 类型]
A --> C[观察 resource 类型]
A --> D[观察 measure 类型]
A --> E[观察 Web Vitals]
B --> F[trackPagePerformance]
C --> G[trackResourcePerformance]
D --> H[trackCustomMetric]
E --> I[trackMetric]
F --> J[计算 loadTime, domContentLoaded 等]
J --> K[调用 trackMetric]
G --> L[判断是否重要资源]
L --> |是| M[调用 trackMetric]
L --> |否| End
H --> K
I --> K
K --> N[addToQueue]
N --> O{队列长度 >= batchSize?}
O --> |是| P[sendBatch]
O --> |否| Q{定时器触发?}
Q --> |是| P
Q --> |否| Wait
P --> R[调用 Supabase insert]
R --> S{成功?}
S --> |是| T[清空队列]
S --> |否| U[重新加入队列]
T --> End
U --> End
Wait --> End
```

**Diagram sources **
- [performanceService.ts](file://src/services/performanceService.ts#L150-L456)

**Section sources**
- [performanceService.ts](file://src/services/performanceService.ts#L1-L500)

### usePerformance 分析
`usePerformance`是一组组合式函数，为Vue组件提供了更高层次的抽象，简化了性能监控的集成。

#### 组合式函数关系
```mermaid
classDiagram
class usePerformanceMonitoring {
+pageLoadTime : Ref~number~
+isLoading : Ref~boolean~
+apiMetrics : Ref~Record~string, any~~
+userActions : Ref~...[]~
+errors : Ref~...[]~
+report : Ref~PerformanceReport | null~
+loading : Ref~boolean~
+error : Ref~string | null~
}
usePerformanceMonitoring <|-- usePagePerformance
usePerformanceMonitoring <|-- useAPIPerformance
usePerformanceMonitoring <|-- useUserBehavior
usePerformanceMonitoring <|-- useErrorTracking
usePerformanceMonitoring <|-- usePerformanceReport
class usePagePerformance {
+markPageStart() : void
+markPageEnd() : void
+measureComponentRender() : void
+measureAsyncOperation() : Promise~T~
}
class useAPIPerformance {
+startAPICall() : string
+endAPICall() : void
+monitoredFetch() : Promise~Response~
}
class useUserBehavior {
+trackUserAction() : void
+trackFormInteraction() : void
+setupClickTracking() : Function
+setupScrollTracking() : Function
}
class useErrorTracking {
+trackError() : void
+withErrorTracking() : T
}
class usePerformanceReport {
+fetchReport() : Promise~void~
+getRealTimeMetrics() : Object
}
```

**Diagram sources **
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L489)

#### 页面性能监控序列图
```mermaid
sequenceDiagram
participant Component as "Vue组件"
participant usePage as "usePagePerformance"
participant PerfService as "performanceService"
Component->>usePage : onMounted()
usePage->>usePage : markPageStart()
usePage->>PerfService : trackCustomMetric("page_start", ...)
usePage->>PerfService : trackMetric("page_load", "total_load_time", ...)
loop 监听路由变化
Component->>usePage : route.path 变化
usePage->>usePage : markPageStart()
end
Component->>usePage : window.load 事件
usePage->>usePage : markPageEnd()
usePage->>PerfService : trackCustomMetric("page_load_complete", ...)
usePage->>PerfService : trackMetric("page_load", "total_load_time", ...)
```

**Diagram sources **
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L150)

**Section sources**
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L489)

### 构建优化脚本分析
`optimize-build.mjs`是一个Node.js脚本，用于在构建前执行一系列性能优化检查。

#### 构建优化流程
```mermaid
flowchart TD
Start([开始]) --> A[清理构建目录]
A --> B[优化依赖]
B --> C[优化图片资源]
C --> D[优化CSS]
D --> E[优化JavaScript]
E --> F[生成优化构建]
F --> G[分析构建结果]
G --> H[检查Gzip压缩效果]
H --> I[生成优化报告]
I --> End([结束])
style Start fill:#4CAF50,stroke:#388E3C
style End fill:#4CAF50,stroke:#388E3C
```

**Diagram sources **
- [optimize-build.mjs](file://scripts/performance/optimize-build.mjs#L1-L437)

**Section sources**
- [optimize-build.mjs](file://scripts/performance/optimize-build.mjs#L1-L437)

## 依赖分析
系统依赖关系清晰。`usePerformance`组合式函数依赖于`performanceService`来上报数据。`performanceService`依赖于`supabase`客户端与后端数据库交互。构建脚本`optimize-build.mjs`独立于前端代码，直接操作文件系统和执行构建命令。

```mermaid
graph LR
A[usePerformance.ts] --> B[performanceService.ts]
B --> C[supabase.ts]
D[optimize-build.mjs] --> E[文件系统]
D --> F[npm run build]
```

**Diagram sources **
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L10)
- [performanceService.ts](file://src/services/performanceService.ts#L1-L10)

**Section sources**
- [usePerformance.ts](file://src/composables/usePerformance.ts#L1-L50)
- [performanceService.ts](file://src/services/performanceService.ts#L1-L50)

## 性能考虑
系统在性能方面进行了精心设计。数据上报采用批量（batchSize=10）和定时（batchTimeout=5000ms）双重机制，有效减少了网络请求次数。内存队列在发送失败时会重新入队，保证了数据不丢失。`usePerformance`中的`measureAsyncOperation`等函数提供了对异步操作的精确监控，有助于定位性能瓶颈。

## 故障排除指南
当性能数据上报出现问题时，可按以下步骤排查：
1.  检查`performanceService.isEnabled`是否为`true`。
2.  查看浏览器控制台是否有"发送性能数据失败"或"发送性能数据异常"的错误日志。
3.  确认Supabase客户端配置正确，且`performance_metrics`表存在。
4.  检查网络连接是否正常。
5.  验证`get_performance_report`数据库函数是否已正确部署。

**Section sources**
- [performanceService.ts](file://src/services/performanceService.ts#L404-L456)

## 结论
`performanceService`及其配套的`usePerformance`组合式函数，构建了一套完整、健壮的前端性能监控体系。它不仅能自动采集关键性能指标，还支持灵活的自定义埋点。与构建优化脚本的结合，形成了从开发、构建到运行时的全链路性能保障闭环。通过持续分析上报的数据，团队可以做出数据驱动的决策，不断优化用户体验。