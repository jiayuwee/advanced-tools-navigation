# 部署配置

<cite>
**本文档引用的文件**
- [Dockerfile](file://config/deployment/Dockerfile)
- [docker-compose.yml](file://config/deployment/docker-compose.yml)
- [nginx.conf](file://config/deployment/nginx.conf)
- [netlify.toml](file://netlify.toml)
- [build-verification.yml](file://advanced-tools-navigation/github/workflows/build-verification.yml)
- [health-check.yml](file://advanced-tools-navigation/github/workflows/health-check.yml)
- [trigger-deployment.js](file://scripts/deployment/trigger-deployment.js)
- [check-deployment-status.js](file://scripts/deployment/check-deployment-status.js)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [Docker 构建策略](#docker-构建策略)
4. [Docker Compose 服务编排](#docker-compose-服务编排)
5. [Nginx 生产级配置](#nginx-生产级配置)
6. [Netlify 自动化部署](#netlify-自动化部署)
7. [CI/CD 流程分析](#cicd-流程分析)
8. [部署问题诊断与修复](#部署问题诊断与修复)
9. [总结](#总结)

## 简介
本文档系统性地讲解 `advanced-tools-navigation` 项目的部署配置策略与实现。详细解析容器化构建、服务编排、Web服务器配置及自动化部署机制，结合CI/CD流程，展示从代码提交到生产环境部署的完整路径，并提供常见问题的诊断与修复指南。

## 项目结构
项目采用模块化结构，核心部署配置文件集中于 `config/deployment` 目录，CI/CD 工作流定义于 `github/workflows`，自动化脚本存放于 `scripts/deployment`。前端代码基于 Vite + Vue 3 构建，部署目标为静态网站。

**Section sources**
- [Dockerfile](file://config/deployment/Dockerfile)
- [docker-compose.yml](file://config/deployment/docker-compose.yml)
- [nginx.conf](file://config/deployment/nginx.conf)
- [netlify.toml](file://netlify.toml)

## Docker 构建策略

### 多阶段构建流程
Dockerfile 采用多阶段构建（Multi-stage Build）策略，分为构建阶段和生产阶段：
1. **构建阶段**：基于 `node:18-alpine` 镜像，安装依赖并执行 `npm run build` 生成生产构建产物
2. **生产阶段**：基于轻量级 `nginx:alpine` 镜像，仅复制构建产物至 Nginx 默认目录，显著减小最终镜像体积

### 基础镜像选择
- 构建阶段使用 `node:18-alpine`：Alpine Linux 提供极小的基础镜像，加快构建速度
- 生产阶段使用 `nginx:alpine`：专为 Web 服务优化，安全且资源占用低

### 依赖安装与构建优化
通过 `npm ci` 而非 `npm install` 安装依赖，确保依赖版本锁定，提升构建可重复性与速度。构建完成后仅保留 `dist` 目录内容，实现镜像最小化。

**Section sources**
- [Dockerfile](file://config/deployment/Dockerfile#L1-L13)

## Docker Compose 服务编排

### 服务定义与端口映射
`docker-compose.yml` 定义了单一服务 `web`：
- 通过 `build: .` 指令使用当前目录的 Dockerfile 构建镜像
- 将容器 80 端口映射到主机 80 端口，实现 Web 访问
- 设置容器名称为 `advanced-tools-navigation`，便于管理

### 运行策略与环境配置
- `restart: unless-stopped`：确保服务在异常退出后自动重启，提升可用性
- 设置 `NODE_ENV=production` 环境变量，确保应用以生产模式运行

该配置适用于本地测试和简单生产部署，结构清晰，易于维护。

**Section sources**
- [docker-compose.yml](file://config/deployment/docker-compose.yml#L1-L15)

## Nginx 生产级配置

### HTTPS 重定向与安全策略
`nginx.conf` 实现了完整的安全配置：
- **HTTP 到 HTTPS 重定向**：所有 80 端口请求强制跳转至 HTTPS，确保通信安全
- **SSL 配置**：启用 TLSv1.2/1.3，使用强加密套件，禁用不安全的会话票据
- **HSTS**：强制浏览器使用 HTTPS，防止降级攻击

### 静态资源优化
- **Gzip 压缩**：对文本类资源启用 Gzip 压缩（级别6），显著减小传输体积
- **缓存策略**：
  - 静态资源（JS/CSS/图片等）：设置 1 年过期，标记为不可变，最大化利用浏览器缓存
  - HTML 文件：禁用缓存，确保用户获取最新版本

### SPA 路由支持与安全头
- **前端路由支持**：通过 `try_files $uri $uri/ /index.html` 实现 Vue Router 的 history 模式
- **安全头设置**：
  - 启用 XSS 保护、内容类型嗅探防护、点击劫持防护
  - 配置 CSP 基本策略，限制资源加载来源
  - 隐藏 Nginx 版本号，减少攻击面

**Section sources**
- [nginx.conf](file://config/deployment/nginx.conf#L1-L85)

## Netlify 自动化部署

### 构建指令与发布目录
`netlify.toml` 定义了 Netlify 平台的部署配置：
- **构建命令**：`rm -rf node_modules && npm cache clean --force && npm ci --prefer-offline --no-audit && npm run build`
  - 强制清理依赖和缓存，确保构建环境纯净
  - 使用 `npm ci` 保证依赖一致性
- **发布目录**：`dist`，与 Vite 构建输出目录一致

### 环境变量管理
- 明确指定 `NODE_VERSION=20`，确保构建环境 Node.js 版本一致
- 通过 `NPM_CONFIG_CACHE` 和 `NETLIFY_SKIP_NPM_CACHE` 强制跳过 Netlify 的 NPM 缓存，避免缓存污染

### 重定向规则
- **SPA 路由**：所有路径请求重定向至 `/index.html`（状态码 200），支持前端路由
- **域名规范化**：
  - HTTP 请求重定向至 HTTPS
  - `www.ramusi.cn` 和 `ramusi.cn` 统一跳转至 `https://ramusi.cn`，避免内容重复

**Section sources**
- [netlify.toml](file://netlify.toml#L1-L37)

## CI/CD 流程分析

### GitHub Actions 工作流
项目配置了两个核心工作流：

#### 构建验证工作流 (`build-verification.yml`)
- **触发条件**：`main` 分支的 `push` 和 `pull_request`
- **核心步骤**：
  1. 检出代码
  2. 缓存 `node_modules` 提升构建速度
  3. 安装依赖（注入 `VITE_SUPABASE_URL` 和 `VITE_SUPABASE_ANON_KEY`）
  4. 执行构建
  5. 验证构建输出（检查 `dist/index.html` 是否存在）
- **部署通知**：当推送到 `main` 分支时，提示 Netlify 将自动部署

#### 健康检查工作流 (`health-check.yml`)
- **触发条件**：`main` 分支 `push`、每6小时定时运行、手动触发
- **检查内容**：
  1. 网站可访问性（HTTP 200）
  2. 基本功能（页面内容包含 "Ramusi"）
- 实现生产环境的持续监控

### 部署自动化脚本
- `trigger-deployment.js`：通过 GitHub API 手动触发部署工作流，提供详细的使用说明和错误排查指南
- `check-deployment-status.js`：查询 GitHub Actions 工作流运行状态，监控部署进度

**Section sources**
- [build-verification.yml](file://advanced-tools-navigation/github/workflows/build-verification.yml#L1-L87)
- [health-check.yml](file://advanced-tools-navigation/github/workflows/health-check.yml#L1-L48)
- [trigger-deployment.js](file://scripts/deployment/trigger-deployment.js#L1-L180)
- [check-deployment-status.js](file://scripts/deployment/check-deployment-status.js#L1-L43)

## 部署问题诊断与修复

### 路由失效
**现象**：直接访问 `/tool/123` 返回 404  
**原因**：Web 服务器未正确配置 SPA 路由  
**修复**：
- **Nginx**：确保 `location /` 块包含 `try_files $uri $uri/ /index.html;`
- **Netlify**：确认 `netlify.toml` 中存在 `[[redirects]]` 规则，`from = "/*"` 且 `status = 200`

### 静态资源 404
**现象**：CSS/JS 文件加载失败  
**原因**：构建路径与服务器配置不匹配  
**修复**：
- 检查 `vite.config.ts` 中的 `base` 配置是否与部署路径一致
- 确认 Nginx 的 `root` 指向正确的构建输出目录（如 `/var/www/ramusi.cn/dist`）
- 验证 Dockerfile 中 `COPY --from=build /app/dist` 路径正确

### 环境变量未加载
**现象**：构建失败，提示 Supabase URL 或 Key 为空  
**原因**：CI/CD 环境未正确注入环境变量  
**修复**：
- **GitHub Actions**：在仓库 Settings > Secrets 中设置 `VITE_SUPABASE_URL` 和 `VITE_SUPABASE_ANON_KEY`
- **Netlify**：在 Site Settings > Build & deploy > Environment 中添加相应环境变量
- 使用 `check-github-secrets.js` 脚本验证配置

### 部署卡住或失败
**现象**：GitHub Actions 工作流未运行或卡在某一步  
**诊断**：
- 运行 `check-deployment-status.js` 查看工作流状态
- 检查 `trigger-deployment.js` 是否成功触发
- 查看工作流日志，定位具体错误（如权限、依赖、构建错误）
- 确认 `GITHUB_TOKEN` 具有 `repo` 和 `workflow` 权限

**Section sources**
- [build-verification.yml](file://advanced-tools-navigation/github/workflows/build-verification.yml#L50-L87)
- [trigger-deployment.js](file://scripts/deployment/trigger-deployment.js#L116-L154)
- [check-deployment-status.js](file://scripts/deployment/check-deployment-status.js#L0-L43)
- [check-github-secrets.js](file://scripts/deployment/check-github-secrets.js#L140-L169)

## 总结
本项目采用现代化的部署策略，结合 Docker 容器化、Nginx 高性能服务、Netlify 无服务器部署和 GitHub Actions CI/CD，构建了稳定、安全、高效的发布流程。多阶段 Docker 构建确保了生产镜像的精简，Nginx 配置实现了安全与性能的平衡，Netlify 的自动化部署简化了发布流程，而 GitHub Actions 提供了完整的构建验证与健康监控。通过系统化的配置和自动化脚本，项目实现了从开发到生产的无缝衔接。